day08

   <시퀀스(Sequence)>
    : 자동적으로 일련번호를 발생시키는 도구
     
	-일련번호 : 기본키(Unique + NOT NULL)

     ex) emp 테이블의 기본키는 empno    	
	
    
        1. [시퀀스 생성 방법] 
	
	[형식]
	CREATE SEQUENCE 시퀀스이름
                START WITH 숫자   ==> 발생시킬 일련번호의 시작값. 생략 시 1부터 시작
                INCREMENT BY 숫자 ==> 발생할 일련번호의 증가값. 생략 시 1  
                MAXVALUE    숫자  
                MINVALUE    숫자     ==> 발생시킬 일련번호의 최댓값과 최솟값. 생략 시 NO 사용(계속 증가)
                CYCLE 또는 NOCYCLE ==> 발생시킬 일련번호가 최댓값에 도달하면 다시 처음부터 시작할지 여부 지정하는 옵션
                                        생략하면 NOCYCLE
                CACHE 숫자(메모리에 저장할 갯수) 또는 NOCACHE  ==> 일련번호 발생 시 임시메모리를 사용할지 여부 지정하는 옵션 (10개)
                                        (미리 일정 갯수를 만들어놓고 메모리에 기억시킨 후 사용한다)
                                        사용 시 속도는 빨라지나 메모리가 줄어든다는 단점이 있다.
                                        사용 안 하면 속도는 느리지만 메모리가 줄지 않는다.
                                        생략 시 NOCACHE

        2. [시퀀스 사용 방법]
            주로 INSERT 명령에서 사용
            
            [형식]
                시퀀스이름.NEXTVAL
                
                [참고]
                    시퀀스가 마지막으로 만든 번호 확인하는 방법
                    : 시퀀스이름.CURRVAL
        
       	 	[시퀀스 문제점]
            		시퀀스는 테이블에 독립적.
            		즉, 한 번 만든 시퀀스는 여러 테이블에서 사용 가능
            		이 때 어떤 테이블에서 시퀀스를 사용하든지 항상 다음 일련번호를 만들어준다.
            
       
        3. [시퀀스 수정 방법]
                
                    ALTER SEQUENCE 시퀀스이름
                        INCREMENT BY 숫자
                        MAXVALUE    숫자[또는 NOMAXVALUE]
                        MINVALUE    숫자[또는 NOMINVALUE]
                        CYCLE[ 또는 NOCYCLE ]
                        CACHE 숫자 [ 또는 NOCACHE ]
            
            [참고]
                시퀀스를 수정하는 경우 시작값은 수정 불가
                이미 발생한 번호이기 때문
                시작번호는 전에 만들어 놓은 시작번호가 자동으로 시작번호가 된다.
       
       4. [시퀀스 삭제 방법]
            [형식]
                DROP SEQUENCE 시퀀스이름;
                

-----------------------------------

    <인덱스(INDEX)>
    : B-Tree 기법으로 색인을 만들어 SELECT 빠르게 처리할 수 있도록 하는 것
    
    [참고]
        인덱스 만들면 안 되는 경우
            1. 데이터 양 적은 경우
               오히려 속도가 떨어진다.
               시스템에 따라서 다르나 최소 몇십만 개 이상의 데이터가 있는 경우에만 효과 있음
        
            2. 데이터 입출력 빈번
               데이터 입력될 때마다 계속해서 색인(인덱스)을 수정해야 하므로 오히려 느림
    
    [참고]
        인덱스 만들면 좋은 경우
            1. JOIN 등이 많이 사용되는 필드가 존재하는 경우
            
            2. NULL 값이 많이 존재하는 경우
            
            3. WHERE 조건절에 많이 사용되는 필드가 존재하는 경우
    
    [참고]
        제약조건을 추가할 때 기본키, 유일키를 부여하면
        자동적으로 해당 필드는 인덱스가 만들어진다.
        별도로 인덱스 만들 필요 없음
    
    [인덱스 만드는 방법]
        [형식]
            1. 일반 인덱스(NON UNIQUE INDEX)
            
                CREATE INDEX 인덱스이름
                ON
                    테이블이름(인덱스에 사용할 필드 이름);
            
                [참고]
                    일반 인덱스는 데이터가 중복돼도 상관없다.
            
            2. UNIQUE INDEX
                : 인덱스용 데이터가 반드시 UNIQUE 하다는 보장이 있는 경우(필드에 U 제약조건 있음)에 한해서
                  인덱스 만드는 방법
                  
                CREATE UNIQUE INDEX 인덱스이름
                ON
                    테이블이름(필드이름);  
                
                [참고]
                    이 때 지정한 필드의 내용은 반드시 유일하다는 보장이 있어야 한다.
                
                [장점]
                    일반 인덱스보다 처리 속도가 아주 빠르다.
                    이진 검색을 사용하기 때문..
            
            3. 결합 인덱스
                : 여러 개의 필드를 결합해서 하나의 인덱스를 만드는 방법
                  여러 개의 필드의 조합이 반드시 유일해야 한다는 전제조건이 있다.
                  
                  즉 하나의 필드만 가지고는 유니크 인덱스를 만들지 못하는 경우
                  여러 개의 필드를 합쳐서 유니크 인덱스를 만들어서 사용하는 방법
                
                CREATE UNIQUE INDEX 인덱스이름
                ON
                    테이블이름(필드이름, 필드이름, ...);
                    
                [참고]
                    복합키 제약조건 추가하기
                    
                    CREATE TABLE 테이블이름(
                        필드1 데이터타입(길이),
                        필드1 데이터타입(길이),
                        필드1 데이터타입(길이),
                        ...
                        CONSTRAINT 제약조건이름 PRIMARY KEY(필드이름, 필드이름2)
                    );
            
            4. 비트 인덱스
                : 주로 그 안에 들어있는 데이터가 몇 가지 중 하나인 경우에 많이 사용되는 방법
                  gen 필드에는 F, M, N만 입력 가능
                  deptno 필드에는 10, 20, 30, 40만 입력 가능
                  위 사례가 내부적으로 데이터를 이용해서 인덱스를 만들어서 사용하는 경우
                  
                CREATE BITMAP INDEX 인덱스이름
                ON 
                    테이블이름(필드이름); => 도메인(데이터의 범위)이 정해져 있는 경우에 한해서만        

------------------------

   <인라인 뷰(InLine View)>
    : 조회질의명령(SELECT 질의명령)을 내리면 발생하는 결과
    
     즉, 뷰는 인라인 뷰 중에서 자주 사용하는 인라인 뷰를 등록해서 사용하는 개념..
     매번 질의명령 만들지 않고 데이터베이스에 만들어 놓는 게 편하기 때문
     
     그런데 인라인 뷰는 하나의 가상의 테이블이다.
     (테이블이란 레코드(행)와 필드(컬럼, 열)로 구성된 데이터를 입력하는 단위)
     테이블이 구조를 갖고 있기에 인라인 뷰는 하나의 테이블로 재사용이 가능하다. (FROM절 안에 들어갈 수 있다.)
     즉, 테이블을 사용해야 하는 곳에는 인라인 뷰를 대신 사용할 수 있다.
     
     
    [사용 목적]
        실제 테이블에 존재하지 않는 데이터를 추가해서 사용해야 하는 경우 유용하다.
        
    [참고]
        ROWNUM
        : 데이터가 조회된 순서를 표시하는 가상의 필드(의사컬럼)
